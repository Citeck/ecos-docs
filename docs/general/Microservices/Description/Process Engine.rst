Process Engine microservice
============================

Микросервис для управления CMMN процессами.

Предъявляемые требования:

1. Отказоустойчивость. При выходе из строя любого узла системы работоспособность должна сохраняться.
2. Сохранность данных. При полной или частичной потере данных на одном из узлов хранилища данные в системе не должны быть потеряны.
3. Горизонтальное масштабирование. При росте количества процессов должна быть возможность горизонтального расширения за счет увеличения количества узлов в кластере, чтобы избежать деградации времени выполнения запросов с увеличением времени жизни системы. Старые процессы, которые уже давно завершились не должны оказывать негативное влияние на активные.

В качестве хранилища для данных выбрана NoSQL БД MongoDB.

Схема связей микросервиса ECOS Process в случае MongoDB:

 .. image:: _static/Process_engine_1.png
       :width: 600
       :align: center

В качестве хранилища для данных в будущем может быть выбрана NoSQL БД Cassandra, которая сможет решить сразу несколько поставленных задач:

1. Автоматическая репликация данных на заданное количество узлов (Сохранность данных)
2. Все ноды в кластере Cassandra являются равнозначными. Мастер отсутствует (Отказоустойчивость)
3. Кластер Cassandra можно гибко конфигурировать и добавлять новые ноды в уже работающую систему (Горизонтальное масштабирование)

Схема связей микросервиса ECOS Process, в случае кластера Cassandra:

Особенности:

1. В Enterprise конфигурации мы получаем 3 уровня горизонтального масштабирования - хранилище, gateway для доступа к хранилищу и кластер stateless микросервисов ECOS Process
2. Так как микросервисы ECOS Process не хранят состояние мы можем отправлять запрос от пользователя на любой из них. Для синхронизации действий между инстансами ECOS Process используется Hazelcast
3. Описание процессов хранится во внешнем микросервисе ECOS Apps, который у нас уже реализован и версионирует любые изменения в процессах
4. Интеграция с внешними событиями осуществляется через очередь сообщений RabbitMQ.
5. Cassandra настраивается на QUORUM Read/Write (N/2 + 1), где N - количество узлов Cassandra. Это означает что запись считается успешной если большинство нод в кластере подтвердили, что запись произошла. Для чтения так же требуется, чтобы большинство нод вернуло актуальные данные. Такая настройка позволяет избежать ситуаций когда сетевые проблемы между нодами кластера приводят к их рассинхронизации.
6. Администратор через центральную конфигурацию может настраивать ECOS Process для подключения к кластеру Cassandra


Жизненный цикл событий и команд
--------------------------------

 .. image:: _static/Process_engine_2.png
       :width: 600
       :align: center

Если к нам приходит внешнее событие (например, кейс создан), то мы опрашиваем хранилище на наличие заинтересованных в этом событии слушателей. У каждого слушателя может быть некоторое условие срабатывания и должна быть команда, которую следует выполнить если произошло событие, которое удовлетворяет условию (если условие отсутствует, то оно считается всегда успешно пройденным).

При поступлении команды (пользовательской или по событию) мы начинаем транзакцию (БД не поддерживает транзакционность и у нас будет свой механизм для этого). После того как транзакция началась мы читаем нужные данные (если таковые имеются) из БД и сохраняем их в памяти. Далее при любом чтении данных мы ищем их в памяти и только если не нашли, то обращаемся в БД.

После получения нужных данных мы запускаем жизненный цикл активностей в ходе которого могут завершиться и начаться неограниченное количество активностей (задач, действий, этапов). Данные в этот момент все хранятся только в памяти. Если все действия прошли успешно, то мы сохраняем состояние процесса в БД, выполняем действия, которые должны выполниться после коммита (например, отправка уведомлений) и отправляем события во внешние системы.

Сущности
----------

Сущности в ECOS Process делятся на базовые (Core) и относящиеся непосредственно к кейс-менеджменту (Case Management Engine). В будущем будет возможность расширить микросервис другими реализациями (например - bpmn).

 .. image:: _static/Process_engine_3.png
       :width: 600
       :align: center

Базовые
~~~~~~~~~

**ProcessDefinition** - описание процесса. Будет общим между инстансами процесса с учетом версионирования. При создании инстанса процесса сохраняется ссылка на текущую ревизию описания процесса и Definition меняется только если явно пришла команда на изменение (изменение базового Definition не будет автоматически менять все запущенные процессы). ProcessDefinition содержит список описаний активностей (ActivityDefinition) и список уже запущенных активностей (ActivityInstance), которые будут копироваться во все инстансы запускаемых процессов при старте.

**ProcessInstance** - инстанс процесса. Хранит свое состояние и состояние всех дочерних активностей.

**ActivityDefinition** - описание активности

**ActivityInstance** - инстанс активности

**SentryDefinition** - описание Sentry, которое включает в себя

   1. event - идентификатор события, за которым следит Sentry
   2. evaluator - условие, по которому Sentry либо сработает либо нет при возникновении события event
   3. command - команда, которая отправляется на выполнение если сработала Sentry

**Role** - роль процесса. Может быть статической и динамической

**Evaluator** - получив на вход событие возвращает true или false

**Command** - команда на выполнение некоторого действия (сменить статус активности, выставить переменную и др.)

Case Management
~~~~~~~~~~~~~~~

**Stage** - контейнер для других активностей

**Action** - некоторое действие, которое не требует участия человека

**Task** - задача, которая делится на **ProcessTask** (выполнение бизнес-процесса) и **User Task** (выполнение простой гибко настраиваемой пользовательской задачи)

Обработка команд (ECOS Commands)
----------------------------------

В кластерной среде при старте микросервисов ECOS Process происходит распределение ответственности за процессы по числовому хэшу следующим образом:

При поднятии кластера каждый инстанс ECOS Process получает порядковый номер, который не будет повторяться между микросервисами.

Далее для определения ответственности за идентификатор процесса считается 4 байтовый хэш, который делится на количество микросервисов в кластере и остаток от деления определяет какой именно микросервис будет обрабатывать запрос.

Когда к нам приходит запрос на выполнение какой-либо команды микросервис сначала определяет ответственного за данный процесс и кладет команду в очередь обработки по id ответственного и ждет пока команда будет выполнена (она может быть выполнена и на текущем микросервисе, но для соблюдения последовательности выполнения команд следует использовать единый подход). Как только команда выполнена или произошла ошибка выполнения микросервис отправляет результат выполнения инициатору если таковой имеется.

На каждом микросервисе есть 1 поток, который занимается обработкой пришедших команд, чтобы избежать проблем с синхронизацией при одновременном изменении одного и того же процесса от разных инициаторов.

Работа с внешними ресурсами
----------------------------

1. При внешних запросах на чтение читаем напрямую и кэшируем в рамках транзакции
2. Все внешние команды собираем в рамках транзакции и если коммит прошел успешно, то отправляем их в очередь на выполнение
3. Если поступает команда мутации записи, то выполняем эту команду над записью в кэше транзакции, чтобы при чтении всегда получать актуальные данные

События (Record Event) (в следующих релизах)
---------------------------------------------

Система событий с возможностью при подписании указать атрибуты, которые необходимы слушателю.

Этап подписания на событие:

Если слушатель поднялся раньше чем источник событий:

1. При старте источник событий рассылает через MQ запрос на всех заинтересованных слушателей
2. Все заинтересованные слушатели отправляют в ответ список атрибутов, в которых они заинтересованы и идентификаторы своих очередей

Если источник событий поднялся раньше слушателя:

1. При старте слушатель рассылает через MQ запрос на подписание указав идентификатор очереди и необходимые атрибуты

Этап возникновения события:

1. Подготавливается базовая информация по событию.
2. Происходит получение атрибутов, в которых заинтересованы слушатели
3. Обогащенное атрибутами событие отправляется в очереди всех заинтересованных слушателей