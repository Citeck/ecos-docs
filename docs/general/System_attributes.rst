.. _system_attributes:

Системные атрибуты
===========================================

.. list-table::
      :widths: 10 30
      :align: center
      :class: tight-table 

      * - **_null**
        - всегда возвращает null значение
      * - **_type**
        - возвращает тип сущности
      * - **_notExists**
        - возвращает true, если сущность не существует
      * - **_has**
        - | проверить наличие чего-то в значении. Например:
 
              .. code-block::

                     permissions._has.Write?bool 

          | проверить наличие прав на изменение сущности   
      * - **_edge**
        - получить мета-информацию об атрибуте. (имя, заголовок, возможность просматривать, возможность редактировать и т.д.)

              .. code-block::

                     _edge.title.protected?bool 

          | например, для того чтобы узнать, что атрибут защищен от редактирования  
      * - **_alias**
        - | алиас сущности при сабмите. Используется, когда нужно создать несколько связанных сущностей. 
          | т.к. ID новых сущностей станет известен только после того, как непосредственно они будут созданы, то необходим какой-то "фэйковый ID", чтобы на него ссылаться в атрибутах. 
          | Например, хотим создать 2 сущности:

              .. code-block::

                    [
                    {"id": "emodel/some-type@", "attributes":{"link":"alias-value-0"}}, // тут link - это ассоциация. В ней мы пишем значение алиаса
                    {"id": "emodel/some-type@", "attributes":{"_alias":"alias-value-0"}, // тут _alias - это тот фейковый id под которым эта сущность представлена. 
                    ]

          | Движок создает сущности с конца. Т.е. сначала создаст

              .. code-block::

                    {"id": "emodel/some-type@", "attributes":{"_alias":"alias-value-0"}

          | получит идентификатор новой сущности **emodel/some-type@123-123-123-123** пробежится по сущностям, 
          | которые будут созданы далее и подменит все "alias-value-0" на реальный ID **(emodel/some-type@123-123-123-123)**
          | т.е. вторая сущность отправится на создание уже в виде^

              .. code-block::

                    {"id": "emodel/some-type@", "attributes":{"link":"emodel/some-type@123-123-123-123"}}
      * - **_parent**
        - ассоциация на родителя
      * - **_parentAtt**
        - родительский атрибут, по которому создается ссылка родитель->дочерняя_сущность
      * - **_formKey**
        - | ключ формы (в множественном варианте), которые можно использовать для редактирования сущности в порядке приоритета от большего к меньшему. 
          | Позволяет связывать сущности без ECOS типа с формами (старые задачи, например)
      * - **_modified**
        - дата изменения сущности
      * - **_modifier**
        - изменивший сущность
      * - **_created**
        - дата изменения сущности
      * - **_creator**
        - создавший сущность
      * - **_content**
        - содержимое сущности
      * - **_actions**
        - действия
      * - **_docNum**
        - номер документа, который генерируется по шаблону нумерации в типе
      * - **_self**
        - | атрибут, который представляет само значение. 
          | Т.е. _self._self._self._self._self это то же самое что и _self._self
          | используется:        
          | 1. Там где значение - это примитив (строка, число), но его нужно отредактировать на форме (форма может редактировать только атрибуты). В этом случае можно добавить на форме атрибут **_self**
          | 2. Там где нам нужно сделать мутацию передав на форме файл (или json объект), который по сути является сборником атрибутов сущности (форма с загрузкой конфигурацией артефактов например). Т.е. мы отправляем на бэк:

              .. code-block::

                    {"id":"abc", "attributes": {"_self": {"first":"second", "third":"fourh"}}}
       
          | и движок это воспринимает все равно что:

              .. code-block::

                    {"id":"abc", "attributes": {"first":"second", "third":"fourh"}}

      * - **_as**
        - | получить значение как что-то другое. Список вариантов зависит от типа значения. 
          | Для строки доступно:
          | используется:        
          | **_as.ref** - получить строку как ссылку на сущность
          | **_as.mltext** - получить строку как multi language text
      * - | **_localId**
          | **_disp**
          | **_str**
        - | :ref:`скаляры<scalars>`, которые можно получить как значения обычных атрибутов. 
          | Т.е. в API доступ к скалярам идет через вопросительный знак (например, **?str** и **?bin**), но поменяв **"?"** на **"_"** мы получим те же данные, но уже в неконечном виде (т.е. можно будет запрашивать вложенные атрибуты). 
          | Как вариант использования - берем свойство, в котором в виде строки записана ссылка на что-то другое. Пишем:  

              .. code-block::

                    someField._str._as.ref.fieldFromRef  
      * - | **_roles.isCurrentUserMemberOf.initiator?bool**
        - | Является ли текущий пользователь представителем роли "инициатор". Вместо ``initiator`` можно подставлять любой идентификатор роли
      * - | **_roles.assigneesOf.initiator[]?str**
        - | Загрузить представителей роли "инициатор". Вместо ``initiator`` можно подставлять любой идентификатор роли
